import { useCallback, useEffect, useRef, useState } from "react";
import { useLocation, useNavigate, useParams } from "react-router-dom";
import "./Dashboard.css";
import Sidebar from "../components/Sidebar";
import ChatPanel from "../components/ChatPanel";
import SummaryPanel from "../components/SummaryPanel";
import TeamPanel from "../components/TeamPanel";
import { GitTextEditorPanel } from "../features/ide/GitTextEditorPanel";
import Manager from "./Manager";
import { fetchTeam, updateInboxTask, getChatMessages, createChat, listAllChats } from "../lib/tasksApi";
import { API_BASE_URL } from "../config";
import Intelligence from "./Intelligence";
import SettingsPage from "./SettingsPage";
import RightPanelDrawer from "../components/RightPanelDrawer";

// ----- Small helper views -----

function TeamView({ user, statuses, liveLog }) {
  const summarize = (text) => { // a
    if (!text) return "thinkingâ€¦";
    const cleaned = text.replace(/\s+/g, " ").trim();
    if (cleaned.length <= 100) return cleaned;
    return cleaned.slice(0, 97) + "â€¦";
  };

  return (
    <div className="chat-wrapper glass">
      <div className="panel-head">
        <div>
          <p className="eyebrow">Live work</p>
          <h2>Team activity</h2>
        </div>
      </div>

      {/* chips */}
      <TeamPanel user={user} statuses={statuses} />

      {/* small hint */}
      <p className="subhead">Updates stream here when Team is selected.</p>

      {/* NEW: live log */}
      <div className="team-live-log">
        <div className="team-live-log-header">
          <p className="eyebrow">Live log</p>
        </div>

        {(!liveLog || liveLog.length === 0) && (
          <p className="subhead">No recent teammate messages yet.</p>
        )}

        {liveLog && liveLog.length > 0 && (
          <ul className="team-live-log-list">
            {liveLog.map((entry) => (
              <li key={entry.id} className="team-live-log-row">
                <span className="team-live-log-name">{entry.name}</span>
                <span className="team-live-log-text">
                  is working on: {summarize(entry.content)}
                </span>
              </li>
            ))}
          </ul>
        )}
      </div>
    </div>
  );
}

function InboxView({ inbox, onTogglePin }) {
  return (
    <div className="chat-wrapper glass">
      <div className="panel-head">
        <div>
          <p className="eyebrow">Inbox</p>
          <h2>Captured tasks</h2>
        </div>
      </div>
      {inbox.length === 0 && <p className="subhead">No tasks yet.</p>}
      <div className="inbox-list">
        {inbox.map((task) => (
          <div className={`inbox-item ${task.status === "done" ? "done" : ""}`} key={task.id}>
            <div className="inbox-title">
              {task.content}
              {task.pinned && (
                <span className="status-pill subtle" style={{ marginLeft: 8 }}>
                  Pinned
                </span>
              )}
              {Array.isArray(task.tags) && task.tags.includes("auto") && (
                <span className="status-pill subtle" style={{ marginLeft: 8 }}>
                  Auto
                </span>
              )}
              {Array.isArray(task.tags) && task.tags.includes("self-reminder") && (
                <span className="status-pill subtle" style={{ marginLeft: 8 }}>
                  Self reminder
                </span>
              )}
              {task.room_name && (
                <span className="status-pill subtle" style={{ marginLeft: 8 }}>
                  From {task.room_name}
                </span>
              )}
            </div>
            <div className="inbox-meta">
              <span>{task.status}</span>
              {task.priority && <span>{task.priority}</span>}
              <div style={{ display: "flex", gap: 6, marginLeft: "auto" }}>
                <button
                  className="btn"
                  style={{ padding: "4px 8px" }}
                  onClick={() => onTogglePin(task)}
                >
                  {task.pinned ? "Unpin" : "Pin"}
                </button>
                {task.status !== "done" && (
                  <button
                    className="btn"
                    style={{ padding: "4px 8px" }}
                    onClick={() => onTogglePin(task, true)}
                  >
                    Mark done
                  </button>
                )}
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

function IdeView() {
  return <GitTextEditorPanel />;
}

// ----- Main dashboard -----

export default function Dashboard() {
  const navigate = useNavigate();
  const [liveLog, setLiveLog] = useState([]);
  const [chatStyle, setChatStyle] = useState("windowed"); // "windowed" | "glass" | "bare"

  // User / auth
  const [user, setUser] = useState(null);
  const [loadingUser, setLoadingUser] = useState(true);
  const [userError, setUserError] = useState("");

  // Room
  const [roomId, setRoomId] = useState(null);
  const [roomData, setRoomData] = useState(null);
  const [roomError, setRoomError] = useState("");
  const [loadingRoom, setLoadingRoom] = useState(true);

  // UI state
  const [activeTool, setActiveTool] = useState("Intelligence");
  const [sidebarCollapsed, setSidebarCollapsed] = useState(
    () => JSON.parse(localStorage.getItem("sidebarCollapsed") || "false")
  );
  const [rightRatio, setRightRatio] = useState(0.35); // fraction for right panel
  const [lastRightRatio, setLastRightRatio] = useState(0.35);
  const [rightCollapsed, setRightCollapsed] = useState(false);
  const containerRef = useRef(null);
  const [dragging, setDragging] = useState(false);
  const rightCollapseTimer = useRef(null);
  const rightScrollTimer = useRef(null);
  const messagesEffectInitial = useRef(true);

  // Activity / team / inbox
  const [activityLog, setActivityLog] = useState([]);
  const [teamMembers, setTeamMembers] = useState([]);
  const [teamStatuses, setTeamStatuses] = useState([]);
  const [inbox, setInbox] = useState([]);

  const [selectedRoomId, setSelectedRoomId] = useState(null);
  const [roomDrawerOpen, setRoomDrawerOpen] = useState(false);
  const [selectedChatId, setSelectedChatId] = useState(null);
  const [messagesByChat, setMessagesByChat] = useState({});
  const [loadingChat, setLoadingChat] = useState(false);
  const [chatError, setChatError] = useState("");
  const [historyRefreshKey, setHistoryRefreshKey] = useState(0);
  const [rightDrawerOpen, setRightDrawerOpen] = useState(false);
  const [rightDrawerTab, setRightDrawerTab] = useState("notifications");
  const chatsCountRef = useRef(0);
  const [allChats, setAllChats] = useState([]);
  const CHAT_STORAGE_KEY = "selectedChatId";
  const [chats, setChats] = useState([]);

  const { chatId } = useParams();
  const [openRoomId, setOpenRoomId] = useState(null);

  const createNewChat = useCallback(
    async (name) => {
      try {
        const fallbackName = name && name.trim() ? name.trim() : `Chat ${chatsCountRef.current + 1}`;
        const newChat = await createChat(fallbackName);
        const id = newChat.id || newChat.chat_id;
        if (id) {
          chatsCountRef.current += 1;
          setAllChats((prev) => [{ ...newChat, name: fallbackName }, ...prev]);
          setSelectedChatId(id);
          setMessagesByChat((prev) => ({ ...prev, [id]: [] }));
          setActiveTool("Chat");
          localStorage.setItem(CHAT_STORAGE_KEY, id);
          navigate(`/app/chat/${id}`);
        }
      } catch (err) {
        console.error("Failed to create chat", err);
        alert("Failed to create chat. Please try again.");
      }
    },
    []
  );

  const handleRoomClick = (room) => {
    const id = room?.id || room?.chat_id || room?.room_id;
    if (!id) return;
    setSelectedChatId(id);
    localStorage.setItem(CHAT_STORAGE_KEY, id);
    setRoomDrawerOpen(false);
    setActiveTool("Chat");
    navigate(`/app/chat/${id}`);
  };

  const handleChatSelect = (chatId) => {
    setSelectedChatId(chatId);
    localStorage.setItem(CHAT_STORAGE_KEY, chatId);
    setRoomDrawerOpen(false);
    setActiveTool("Chat");
    navigate(`/app/chat/${chatId}`);
  };

  useEffect(() => {
    if (!roomData || !Array.isArray(roomData.messages)) {
      setLiveLog([]);
      return;
    }
  
    const latestBySender = {};
  
    for (const msg of roomData.messages) {
      if (msg.role !== "user") continue;
  
      const key = msg.sender_id || msg.sender_name || "unknown";
      if (
        !latestBySender[key] ||
        new Date(msg.created_at) > new Date(latestBySender[key].created_at)
      ) {
        latestBySender[key] = msg;
      }
    }
  
    const entries = Object.values(latestBySender)
      .map((msg) => ({
        id: msg.id,
        name: msg.sender_name || "Teammate",
        content: msg.content || "",
        at: msg.created_at,
      }))
      .sort((a, b) => new Date(b.at) - new Date(a.at));
  
    setLiveLog(entries);
  }, [roomData]);

  useEffect(() => {
    const fetchMe = async () => {
      try {
        setLoadingUser(true);
        const res = await fetch(`${API_BASE_URL}/api/me`, {
          credentials: "include",
        });
        if (res.ok) {
          const data = await res.json();
          console.log("ðŸ” /api/me response:", data);
          setUser({
            id: data.id,
            name: data.name || data.email || "You",
            email: data.email,
            role: data.role,
            is_platform_admin: data.is_platform_admin,
          });
          setUserError("");
        } else {
          const text = await res.text();
          console.error("Failed /me", res.status, text);
          setUser(null);
          setUserError("Not logged in.");
        }
      } catch (err) {
        console.error("Error fetching /me", err);
        setUserError("Failed to reach server.");
      } finally {
        setLoadingUser(false);
      }
    };

    fetchMe();
  }, []);

  useEffect(() => {
    if (!user) return;

    const loadTeam = async () => {
      try {
        const members = (await fetchTeam()) || [];
        setTeamMembers(members);
      } catch (err) {
        console.error("Failed to load team for activity view", err);
      }
    };

    loadTeam();
    const id = setInterval(loadTeam, 10000);
    return () => clearInterval(id);
  }, [user]);

  const loadMessagesForChat = useCallback(
    async (chatId) => {
      if (!chatId) return;
      console.group("ðŸ“¨ [LOAD MESSAGES] Fetching history");
      console.log("chatId:", chatId);
      console.log("Is this initial mount?", messagesEffectInitial.current);
      try {
        setLoadingChat(true);
        setChatError("");

        console.log("ðŸ”· Calling getChatMessages...");
        const data = await getChatMessages(chatId);

        console.log("âœ… Messages loaded:", data);
        // FIX: Backend returns {chat: {...}, messages: [...]}
        const messages = Array.isArray(data)
          ? data
          : Array.isArray(data?.messages)
          ? data.messages
          : [];
        console.log("Message count:", messages.length);
        if (messages.length > 0) {
          console.log("First message:", messages[0]);
          console.log("Last message:", messages[messages.length - 1]);
        }

        setMessagesByChat((prev) => ({
          ...prev,
          [chatId]: messages,
        }));
      } catch (err) {
        console.error("âŒ Failed to load messages:", err);
        console.error("Error details:", err.message);
        setChatError(`Failed to load messages: ${err.message}`);
        setMessagesByChat((prev) => ({
          ...prev,
          [chatId]: [],
        }));
      } finally {
        setLoadingChat(false);
        console.groupEnd();
        messagesEffectInitial.current = false;
      }
    },
    []
  );

  useEffect(() => {
    if (!selectedChatId) {
      console.group("ðŸ“¨ [LOAD MESSAGES] Effect triggered");
      console.log("selectedChatId:", selectedChatId);
      console.log("No chat selected, clearing messages");
      console.groupEnd();
      setMessagesByChat({});
      messagesEffectInitial.current = false;
      return;
    }

    loadMessagesForChat(selectedChatId);
  }, [selectedChatId, loadMessagesForChat]);

  // Rooms are no longer user-facing; skip auto-select by room to avoid 403s

  useEffect(() => {
    if (!user) return;

    const label =
      activeTool === "IDE"
        ? "Development"
        : activeTool === "History"
        ? "Activity history"
        : activeTool === "Inbox"
        ? "Inbox review"
        : activeTool === "Team"
        ? "Team activity"
        : "In chat";

    const entry = {
      id: `${Date.now()}`,
      state: label,
      detail: `Switched to ${activeTool}`,
      at: new Date().toLocaleTimeString([], {
        hour: "2-digit",
        minute: "2-digit",
      }),
      name: user.name || "You",
    };
    setActivityLog((prev) => [entry, ...prev].slice(0, 6));

    const roomMembers =
      (Array.isArray(roomData?.members) && roomData.members.length > 0
        ? roomData.members
        : teamMembers.length > 0
        ? teamMembers
        : [user]
      ).filter(Boolean);

    const seen = new Set();
    const uniqueMembers = [];
    for (const m of roomMembers) {
      const key = m.id || m.user_id || m.userId || m.email || m.name;
      if (key && seen.has(key)) continue;
      if (key) seen.add(key);
      uniqueMembers.push(m);
    }

    const statuses = uniqueMembers.map((m) => {
      const memberId = m.id || m.user_id || m.userId;
      const isSelf = memberId && memberId === user.id;
      const displayName = m.name || m.email || "Teammate";
      const primaryRole =
        (Array.isArray(m.roles) && m.roles[0]) || m.role || "Teammate";

      return {
        name: displayName,
        role: isSelf ? label : primaryRole,
        state: isSelf ? "active" : "online",
      };
    });

    setTeamStatuses(statuses);
  }, [activeTool, user, teamMembers, roomData]);

  // Room polling removed to avoid 403 when room is not accessible; chats are roomless in UI

  useEffect(() => {
    // No-op: room resolution disabled
    setLoadingRoom(false);
  }, [user]);

  const handleLogout = async () => {
    try {
      await fetch(`${API_BASE_URL}/api/auth/logout`, {
        method: "POST",
        credentials: "include",
      });
    } catch {
      // ignore
    } finally {
      window.location.reload();
    }
  };

  const togglePin = async (task, markDone = false) => {
    if (!user?.id || !task?.id) return;
    try {
      const payload = markDone
        ? { status: "done" }
        : { pinned: !task.pinned };
      const updated = await updateInboxTask(user.id, task.id, payload);
      setInbox((prev) =>
        prev.map((t) =>
          t.id === task.id
            ? {
                ...t,
                pinned:
                  updated?.pinned ?? (markDone ? t.pinned : !task.pinned),
                status: updated?.status || (markDone ? "done" : t.status),
              }
            : t
        )
      );
    } catch (err) {
      console.error("Failed to toggle pin", err);
    }
  };

  const renderRight = () => {
    if (activeTool === "Manager") return <Manager currentUser={user} />;

    if (activeTool === "Team")
      return (
        <div className="dashboard-right">
          <TeamView user={user} statuses={teamStatuses} liveLog={liveLog} />
          <NotificationsPanel user={user} />
        </div>
      );

    if (activeTool === "Notifications")
      return (
        <div className="dashboard-right">
          <NotificationsPanel user={user} />
        </div>
      );

    if (activeTool === "IDE")
      return (
        <div className="dashboard-right">
          <IdeView />
        </div>
      );

    if (activeTool === "History")
      return (
        <div className="dashboard-right">
          <HistoryPanel refreshToken={historyRefreshKey} />
        </div>
      );

    return (
      <div className="dashboard-right">
        <SummaryPanel
          user={user}
          activeTool={activeTool}
          activityLog={activityLog}
          roomData={roomData}
        />
      </div>
    );
  };

  useEffect(() => {
    localStorage.setItem("sidebarCollapsed", JSON.stringify(sidebarCollapsed));
  }, [sidebarCollapsed]);

  const location = useLocation();
  const isSettings = location.pathname.startsWith("/app/settings");

  useEffect(() => {
    const move = (e) => {
      if (!dragging || !containerRef.current || rightCollapsed) return;
      const rect = containerRef.current.getBoundingClientRect();
      const sidebarWidth = sidebarCollapsed ? 80 : 260;
      const usable = rect.width - sidebarWidth;
      const x = e.clientX - rect.left - sidebarWidth;
      const ratio = Math.min(Math.max(x / usable, 0.2), 0.6);
      setRightRatio(1 - ratio);
      setLastRightRatio(1 - ratio);
    };
    const up = () => setDragging(false);
    if (dragging) {
      window.addEventListener("mousemove", move);
      window.addEventListener("mouseup", up);
    }
    return () => {
      window.removeEventListener("mousemove", move);
      window.removeEventListener("mouseup", up);
    };
  }, [dragging, sidebarCollapsed, rightCollapsed]);

  useEffect(() => {
    return () => {
      if (rightCollapseTimer.current) clearTimeout(rightCollapseTimer.current);
    };
  }, []);

  const handleNavSelect = async (label) => {
    if (label === "NewChat") {
      const name = window.prompt("Name your chat", `Chat ${chatsCountRef.current + 1}`) || "";
      await createNewChat(name);
      return;
    }
    setActiveTool(label);
    if (isSettings) {
      navigate("/app");
    }
  };

  const bumpHistory = () => setHistoryRefreshKey((k) => k + 1);

  const containerClass = sidebarCollapsed
    ? "dashboard-container collapsed"
    : "dashboard-container";
  const sidebarWidth = sidebarCollapsed ? "80px" : "260px";
  const chatFraction = rightCollapsed ? 1 : 1 - rightRatio;
  const containerStyle = {
    gridTemplateColumns: `${sidebarWidth} ${chatFraction}fr ${
      rightCollapsed ? "24px" : `${rightRatio}fr`
    }`,
  };

  const currentMessages = selectedChatId
    ? messagesByChat[selectedChatId] || []
    : [];

  useEffect(() => {
    // route-based chat selection
    const path = location.pathname;
    const match = path.match(/\/chat\/([^/]+)/);
    if (match && match[1] !== selectedChatId) {
      setSelectedChatId(match[1]);
      localStorage.setItem(CHAT_STORAGE_KEY, match[1]);
      setActiveTool("Chat");
    }
  }, [location.pathname, selectedChatId]);

  useEffect(() => {
    const fetchChats = async () => {
      try {
        const data = await listAllChats();
        const list = Array.isArray(data) ? data : [];
        setAllChats(list);
        chatsCountRef.current = list.length;
        // If URL has chatId, use that
        if (chatId && list.some(c => (c.id || c.chat_id) === chatId)) {
          setSelectedChatId(chatId);
          localStorage.setItem(CHAT_STORAGE_KEY, chatId);
        } else if (!selectedChatId && list.length > 0) {
          const stored = localStorage.getItem(CHAT_STORAGE_KEY);
          const existsStored = stored && list.some((c) => (c.id || c.chat_id) === stored);
          const nextId = existsStored ? stored : list[0].id || list[0].chat_id;
          if (nextId) {
            setSelectedChatId(nextId);
            localStorage.setItem(CHAT_STORAGE_KEY, nextId);
          }
        }
      } catch (err) {
        console.error("Failed to fetch chats list", err);
      }
    };
    fetchChats();
  }, [chatId, selectedChatId]);

  const handleMessagesUpdate = useCallback(
    (chatIdFromChild, newMessages) => {
      const targetId = chatIdFromChild || selectedChatId;
      if (!targetId) return;
      console.log("Messages updated:", (newMessages || []).length, "for", targetId);
      setMessagesByChat((prev) => ({
        ...prev,
        [targetId]: newMessages || [],
      }));
    },
    [selectedChatId]
  );

  const rightSections = ["Summary"];
  const handleRightScroll = (e) => {
    if (rightCollapsed || isSettings) return;
    if (rightScrollTimer.current) {
      return;
    }
    if (Math.abs(e.deltaY) < 80) return;
    const dir = e.deltaY > 0 ? 1 : -1;
    const idx = rightSections.indexOf(activeTool);
    if (idx === -1) return;
    const nextIdx = Math.min(
      rightSections.length - 1,
      Math.max(0, idx + dir)
    );
    if (nextIdx !== idx) {
      setActiveTool(rightSections[nextIdx]);
    }
    rightScrollTimer.current = setTimeout(() => {
      rightScrollTimer.current = null;
    }, 300);
  };

  if (loadingUser) {
    return <div className="dashboard-loading">Loading your workspaceâ€¦</div>;
  }

  if (!user) {
    return (
      <div className="dashboard-loading">
        {userError || "You're not logged in."}
      </div>
    );
  }

  if (loadingRoom && !roomId && !roomError) {
    return (
      <div className="dashboard-loading">
        Setting up your team roomâ€¦
      </div>
    );
  }

  if (roomError && !roomId) {
    return (
      <div className="dashboard-loading">
        {roomError || "Could not load your team room."}
      </div>
    );
  }

  return (
    <div className={containerClass} style={containerStyle} ref={containerRef}>
      <Sidebar
        active={activeTool}
        onSelect={handleNavSelect}
        onToggle={() => setSidebarCollapsed((c) => !c)}
        onLogout={handleLogout}
        currentRoomId={selectedRoomId}
        onRoomClick={handleRoomClick}
        currentUser={user}
        collapsed={sidebarCollapsed}
        onCollapseToggle={(next) =>
          setSidebarCollapsed((c) =>
            typeof next === "boolean" ? next : !c
          )
        }
        chats={allChats}  // ADD THIS
        openRoomId={selectedChatId}  // ADD THIS
      />

      <div
        style={{
          position: "fixed",
          top: "40%",
          right: 0,
          zIndex: 1400,
        }}
      >
        <button
          className="auth-button"
          style={{
            padding: "10px 12px",
            borderTopLeftRadius: "8px",
            borderBottomLeftRadius: "8px",
            borderTopRightRadius: 0,
            borderBottomRightRadius: 0,
            writingMode: "vertical-rl",
          }}
          title="Open panel"
          onClick={() => setRightDrawerOpen(true)}
        >
          Panel
        </button>
      </div>

      <RightPanelDrawer
        isOpen={rightDrawerOpen}
        onClose={() => setRightDrawerOpen(false)}
        initialTab={rightDrawerTab}
      />

      {isSettings ? (
        <div style={{ gridColumn: "span 2", width: "100%", padding: 12 }}>
          <SettingsPage />
        </div>
      ) : activeTool === "Manager" ? (
        <div style={{ gridColumn: "span 2", width: "100%" }}>
          <Manager currentUser={user} />
        </div>
      ) : activeTool === "Intelligence" ? (
        <div
          style={{
            gridColumn: "span 2",
            width: "100%",
            padding: 12,
            overflowY: "auto",
            maxHeight: "100vh",
          }}
        >
          <Intelligence onHistoryChange={bumpHistory} />
        </div>
      ) : (
        <>
          <div className="dashboard-main">
            <div className="chat-style-switch">
              <label className={`chat-style-pill ${chatStyle === "windowed" ? "active" : ""}`}>
                <input
                  type="radio"
                  name="chatStyle"
                  value="windowed"
                  checked={chatStyle === "windowed"}
                  onChange={() => setChatStyle("windowed")}
                />
                Classic
              </label>
              <label className={`chat-style-pill ${chatStyle === "glass" ? "active" : ""}`}>
                <input
                  type="radio"
                  name="chatStyle"
                  value="glass"
                  checked={chatStyle === "glass"}
                  onChange={() => setChatStyle("glass")}
                />
                Glass
              </label>
              <label className={`chat-style-pill ${chatStyle === "bare" ? "active" : ""}`}>
                <input
                  type="radio"
                  name="chatStyle"
                  value="bare"
                  checked={chatStyle === "bare"}
                  onChange={() => setChatStyle("bare")}
                />
                Minimal
              </label>
            </div>
            {chatError && (
              <div className="status-bubble error" style={{ marginBottom: 10 }}>
                {chatError}
              </div>
            )}
            <div className={`chat-container chat-${chatStyle}`}>
              <ChatPanel
                user={user}
                roomId={selectedRoomId || roomId}
                chatId={selectedChatId}
                initialMessages={currentMessages}
                onMessagesUpdate={handleMessagesUpdate}
              />
            </div>
            {loadingChat && (
              <div style={{ padding: "20px", textAlign: "center" }}>
                Loading messages...
              </div>
            )}
            {!loadingChat &&
              currentMessages.length === 0 &&
              selectedChatId &&
              !chatError && (
                <div
                  style={{
                    padding: "20px",
                    textAlign: "center",
                    color: "var(--text-muted)",
                  }}
                >
                  No messages yet. Start the conversation!
                </div>
              )}
          </div>
          {!isSettings && (
            <div
              className={`dashboard-right-wrapper ${
                rightCollapsed ? "collapsed" : ""
              }`}
              onMouseEnter={() => {
                if (rightCollapseTimer.current) {
                  clearTimeout(rightCollapseTimer.current);
                  rightCollapseTimer.current = null;
                }
                if (rightCollapsed) {
                  setRightCollapsed(false);
                  setRightRatio(lastRightRatio || 0.35);
                }
              }}
              onMouseLeave={() => {
                if (rightCollapseTimer.current) {
                  clearTimeout(rightCollapseTimer.current);
                  rightCollapseTimer.current = null;
                }
                rightCollapseTimer.current = setTimeout(() => {
                  setRightCollapsed(true);
                  setLastRightRatio(rightRatio || lastRightRatio || 0.35);
                  setRightRatio(0);
                }, 150);
              }}
              onWheel={handleRightScroll}
            >
              {rightCollapsed ? (
                <div
                  className="right-tab"
                  title="Expand panel"
                  onMouseDown={() => {
                    setRightCollapsed(false);
                    setRightRatio(lastRightRatio || 0.35);
                    setDragging(true);
                  }}
                >
                  â€¹
                </div>
              ) : (
                <>
                  <div
                    className="split-resizer"
                    onMouseDown={() => setDragging(true)}
                    title="Drag to resize"
                  />
                  {renderRight()}
                </>
              )}
            </div>
          )}
        </>
      )}
    </div>
  );
}
